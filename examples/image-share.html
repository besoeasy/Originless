<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Originless Image Share</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
</head>

<body class="min-h-screen bg-slate-950 text-slate-100">
  <div id="app" class="max-w-5xl mx-auto px-6 py-10">
    <header class="mb-10">
      <p class="text-sm uppercase tracking-[0.3em] text-slate-400">Originless</p>
      <h1 class="text-4xl font-bold mt-3">Image Share</h1>
      <p class="text-slate-300 mt-3 max-w-2xl">
        Upload an image to Originless and share the link. Anyone with the link can preview it instantly.
      </p>
      <div class="mt-6 bg-slate-900/70 border border-slate-800 rounded-xl p-4">
        <p class="text-xs text-slate-400">Originless Server</p>
        <p class="text-sm font-mono break-all">{{ originlessServer }}</p>
      </div>
    </header>

    <div class="grid gap-8 lg:grid-cols-2">
      <section class="bg-slate-900/60 border border-slate-800 rounded-2xl p-6 shadow-xl">
        <h2 class="text-2xl font-semibold mb-4">Upload an image</h2>
        <label class="block text-sm text-slate-300 mb-2">Choose image</label>
        <input type="file" accept="image/*" @change="handleFile"
          class="w-full bg-slate-950 border border-slate-800 rounded-xl px-4 py-3 text-slate-100 focus:outline-none focus:ring-2 focus:ring-slate-500" />

        <div v-if="previewUrl" class="mt-4">
          <p class="text-xs text-slate-400 mb-2">Preview</p>
          <img :src="previewUrl" alt="Preview" class="rounded-xl border border-slate-800 max-h-64 object-contain" />
        </div>

        <div class="mt-5">
          <label class="inline-flex items-center gap-2 text-sm text-slate-300">
            <input type="checkbox" v-model="encryptEnabled" class="rounded border-slate-700 bg-slate-950" />
            Encrypt before upload
          </label>
        </div>

        <div v-if="encryptEnabled" class="mt-4">
          <label class="block text-sm text-slate-300 mb-2">Passphrase</label>
          <div class="flex gap-2">
            <input v-model="passphrase" type="text"
              class="flex-1 bg-slate-950 border border-slate-800 rounded-xl px-4 py-3 text-slate-100 focus:outline-none focus:ring-2 focus:ring-slate-500"
              placeholder="Create or paste a passphrase" />
            <button @click="generatePassphrase"
              class="px-4 py-3 rounded-xl bg-slate-200 text-slate-900 font-semibold hover:bg-white transition">Generate</button>
          </div>
          <p class="text-xs text-slate-500 mt-2">Passphrase is required to decrypt. It is never uploaded.</p>
        </div>

        <div class="mt-5 flex flex-wrap gap-3">
          <button @click="uploadImage" :disabled="busy || !file || (encryptEnabled && !passphrase)"
            class="px-5 py-3 rounded-xl bg-emerald-400 text-slate-900 font-semibold hover:bg-emerald-300 disabled:opacity-50 disabled:cursor-not-allowed transition">
            {{ busy ? 'Uploading...' : 'Upload Image' }}
          </button>
          <button @click="resetAll" class="px-5 py-3 rounded-xl text-slate-400 hover:text-slate-100 transition">
            Reset
          </button>
        </div>

        <div v-if="uploadResult" class="mt-6 space-y-4">
          <div class="bg-emerald-950/40 border border-emerald-700 rounded-xl p-4">
            <p class="text-xs text-emerald-200">Uploaded CID</p>
            <p class="font-mono text-sm break-all mt-1">{{ uploadResult.cid }}</p>
            <p class="text-xs text-emerald-200 mt-2">Gateway URL</p>
            <a :href="uploadResult.url" target="_blank"
              class="text-xs text-emerald-300 break-all hover:underline">{{ uploadResult.url }}</a>
          </div>

          <div class="bg-slate-950 border border-slate-800 rounded-xl p-4">
            <p class="text-xs text-slate-400">Share link</p>
            <div class="flex gap-2 mt-2">
              <input type="text" readonly :value="shareLink"
                class="flex-1 bg-slate-950 border border-slate-800 rounded-lg px-3 py-2 text-xs font-mono text-slate-200" />
              <button @click="copyShareLink"
                class="px-4 py-2 rounded-lg bg-slate-200 text-slate-900 font-semibold hover:bg-white transition">Copy</button>
            </div>
            <p v-if="encryptEnabled" class="text-xs text-slate-500 mt-2">Share the link securely (includes passphrase).</p>
          </div>
        </div>

        <div v-if="error" class="mt-6 text-sm text-red-300 bg-red-900/30 border border-red-800 rounded-xl p-3">
          {{ error }}
        </div>
      </section>

      <section class="bg-slate-900/60 border border-slate-800 rounded-2xl p-6 shadow-xl">
        <h2 class="text-2xl font-semibold mb-4">View an image</h2>
        <p class="text-sm text-slate-400 mb-4">Paste a share link, gateway URL, or CID.</p>

        <label class="block text-sm text-slate-300 mb-2">Image URL, CID, or encrypted payload</label>
        <input v-model="viewSource" type="text"
          class="w-full bg-slate-950 border border-slate-800 rounded-xl px-4 py-3 text-slate-100 focus:outline-none focus:ring-2 focus:ring-slate-500"
          placeholder="https://.../ipfs/<cid> or CID" />

        <div class="mt-4">
          <label class="block text-sm text-slate-300 mb-2">Passphrase (for encrypted images)</label>
          <input v-model="viewPassphrase" type="text"
            class="w-full bg-slate-950 border border-slate-800 rounded-xl px-4 py-3 text-slate-100 focus:outline-none focus:ring-2 focus:ring-slate-500"
            placeholder="Paste passphrase" />
        </div>

        <div class="mt-5 flex flex-wrap gap-3">
          <button @click="loadImage" :disabled="busy || !viewSource"
            class="px-5 py-3 rounded-xl bg-sky-400 text-slate-900 font-semibold hover:bg-sky-300 disabled:opacity-50 disabled:cursor-not-allowed transition">
            {{ busy ? 'Loading...' : 'Load Image' }}
          </button>
          <button @click="pasteFromHash" class="px-5 py-3 rounded-xl border border-slate-700 text-slate-200 font-semibold hover:border-slate-400 transition">
            Load from link hash
          </button>
        </div>

        <div v-if="viewUrl" class="mt-6">
          <p class="text-xs text-slate-400 mb-2">Image preview</p>
          <img :src="viewUrl" alt="Shared image" class="rounded-xl border border-slate-800 max-h-72 object-contain" />
          <p class="text-xs text-slate-500 mt-2 break-all">{{ viewUrl }}</p>
        </div>

        <div v-if="viewError" class="mt-6 text-sm text-red-300 bg-red-900/30 border border-red-800 rounded-xl p-3">
          {{ viewError }}
        </div>
      </section>
    </div>

    <footer class="mt-12 text-xs text-slate-500">
      Images are uploaded unpinned; availability depends on IPFS propagation and your node's retention policy.
    </footer>
  </div>

  <script>
    const Originless_Server = "https://filedrop.besoeasy.com";
    const gatewayBase = "https://dweb.link/ipfs/";

    const { createApp } = Vue;

    createApp({
      data() {
        return {
          originlessServer: Originless_Server,
          file: null,
          previewUrl: "",
          uploadResult: null,
          shareLink: "",
          viewSource: "",
          viewUrl: "",
          viewPassphrase: "",
          passphrase: "",
          encryptEnabled: false,
          error: "",
          viewError: "",
          busy: false,
        };
      },
      mounted() {
        this.pasteFromHash();
      },
      methods: {
        resetAll() {
          this.file = null;
          this.previewUrl = "";
          this.uploadResult = null;
          this.shareLink = "";
          this.viewSource = "";
          this.viewUrl = "";
          this.viewPassphrase = "";
          this.passphrase = "";
          this.encryptEnabled = false;
          this.error = "";
          this.viewError = "";
        },
        generatePassphrase() {
          const bytes = new Uint8Array(16);
          crypto.getRandomValues(bytes);
          this.passphrase = Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");
        },
        handleFile(event) {
          const selected = event.target.files[0];
          if (!selected) {
            this.file = null;
            this.previewUrl = "";
            return;
          }
          this.file = selected;
          this.previewUrl = URL.createObjectURL(selected);
        },
        async uploadImage() {
          this.error = "";
          this.viewError = "";
          this.viewUrl = "";
          this.uploadResult = null;
          this.shareLink = "";

          try {
            this.busy = true;

            let response;
            if (this.encryptEnabled) {
              const payload = await this.encryptImageFile(this.file, this.passphrase);
              const file = new Blob([JSON.stringify(payload)], { type: "application/json" });
              const formData = new FormData();
              formData.append("file", file, "encrypted-image.json");

              response = await fetch(`${Originless_Server}/upload`, {
                method: "POST",
                body: formData,
              });
            } else {
              const formData = new FormData();
              formData.append("file", this.file);

              response = await fetch(`${Originless_Server}/upload`, {
                method: "POST",
                body: formData,
              });
            }

            if (!response.ok) {
              const text = await response.text();
              throw new Error(text || `Upload failed (${response.status})`);
            }

            const result = await response.json();
            this.uploadResult = {
              cid: result.cid,
              url: result.url,
            };
            this.shareLink = this.buildShareLink(result.url, this.encryptEnabled ? this.passphrase : "");
            this.viewSource = result.url;
            this.viewUrl = result.url;
            this.viewPassphrase = this.encryptEnabled ? this.passphrase : "";
          } catch (err) {
            this.error = err.message || "Failed to upload image";
          } finally {
            this.busy = false;
          }
        },
        buildShareLink(url, passphrase) {
          const params = new URLSearchParams();
          if (url) {
            params.set("u", url);
          }
          if (passphrase) {
            params.set("k", passphrase);
          }
          return `${location.origin}${location.pathname}#${params.toString()}`;
        },
        pasteFromHash() {
          if (!location.hash) return;
          const params = new URLSearchParams(location.hash.slice(1));
          const url = params.get("u");
          const key = params.get("k");
          if (url) {
            this.viewSource = url;
            this.viewUrl = url;
          }
          if (key) {
            this.viewPassphrase = key;
          }
        },
        async loadImage() {
          this.viewError = "";
          this.viewUrl = "";

          const source = this.viewSource.trim();
          if (!source) return;

          try {
            const payload = await this.resolvePayload(source);
            if (payload.plainUrl) {
              this.viewUrl = payload.url;
              return;
            }

            if (!this.viewPassphrase) {
              throw new Error("Passphrase required for encrypted images");
            }

            const blobUrl = await this.decryptImagePayload(payload, this.viewPassphrase);
            this.viewUrl = blobUrl;
          } catch (err) {
            this.viewError = err.message || "Unable to load image";
          }
        },
        async resolvePayload(source) {
          if (/^https?:\/\//i.test(source)) {
            const response = await fetch(source);
            if (!response.ok) {
              throw new Error(`Failed to fetch payload (${response.status})`);
            }
            const contentType = response.headers.get("content-type") || "";
            if (contentType.includes("application/json")) {
              return await response.json();
            }
            return { plainUrl: true, url: source };
          }

          if (/^[a-z0-9]{46,}$/i.test(source)) {
            const url = `${gatewayBase}${source}`;
            const response = await fetch(url);
            if (!response.ok) {
              throw new Error(`Failed to fetch payload (${response.status})`);
            }
            const contentType = response.headers.get("content-type") || "";
            if (contentType.includes("application/json")) {
              return await response.json();
            }
            return { plainUrl: true, url };
          }

          try {
            return JSON.parse(source);
          } catch (err) {
            throw new Error("Unrecognized URL, CID, or payload");
          }
        },
        async encryptImageFile(file, passphrase) {
          const salt = crypto.getRandomValues(new Uint8Array(16));
          const iv = crypto.getRandomValues(new Uint8Array(12));
          const key = await this.deriveKey(passphrase, salt);
          const buffer = await file.arrayBuffer();
          const ciphertext = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, buffer);

          return {
            v: 1,
            type: file.type || "application/octet-stream",
            name: file.name || "image",
            size: file.size,
            alg: "AES-GCM",
            kdf: "PBKDF2-SHA256",
            iter: 150000,
            salt: this.toBase64(salt),
            iv: this.toBase64(iv),
            ct: this.toBase64(new Uint8Array(ciphertext)),
            createdAt: new Date().toISOString(),
          };
        },
        async decryptImagePayload(payload, passphrase) {
          if (!payload || !payload.ct) {
            throw new Error("Invalid encrypted payload");
          }
          const salt = this.fromBase64(payload.salt);
          const iv = this.fromBase64(payload.iv);
          const key = await this.deriveKey(passphrase, salt, payload.iter || 150000);
          const ciphertext = this.fromBase64(payload.ct);

          try {
            const plaintextBuffer = await crypto.subtle.decrypt({ name: "AES-GCM", iv }, key, ciphertext);
            const blob = new Blob([plaintextBuffer], { type: payload.type || "application/octet-stream" });
            return URL.createObjectURL(blob);
          } catch (err) {
            throw new Error("Unable to decrypt image. Check the passphrase.");
          }
        },
        async deriveKey(passphrase, salt, iter = 150000) {
          const baseKey = await crypto.subtle.importKey(
            "raw",
            new TextEncoder().encode(passphrase),
            "PBKDF2",
            false,
            ["deriveKey"]
          );

          return crypto.subtle.deriveKey(
            { name: "PBKDF2", salt, iterations: iter, hash: "SHA-256" },
            baseKey,
            { name: "AES-GCM", length: 256 },
            false,
            ["encrypt", "decrypt"]
          );
        },
        toBase64(bytes) {
          let binary = "";
          const chunkSize = 0x8000;
          for (let i = 0; i < bytes.length; i += chunkSize) {
            const chunk = bytes.subarray(i, i + chunkSize);
            binary += String.fromCharCode.apply(null, chunk);
          }
          return btoa(binary);
        },
        fromBase64(base64) {
          const binary = atob(base64);
          const bytes = new Uint8Array(binary.length);
          for (let i = 0; i < binary.length; i++) {
            bytes[i] = binary.charCodeAt(i);
          }
          return bytes;
        },
        async copyShareLink() {
          if (!this.shareLink) return;
          await navigator.clipboard.writeText(this.shareLink);
        },
      },
    }).mount("#app");
  </script>
</body>

</html>
